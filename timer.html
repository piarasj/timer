<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cycling Timer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;           /* pure black, up into browser area on iOS */
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      font-family: -apple-system, system-ui, Segoe UI, Roboto, sans-serif;
      color: #aaa;
    }
    canvas { display: block; width: 100vw; height: 100vh; }
    #message {
      position: absolute;
      top: env(safe-area-inset-top, 10px);
      left: 0; right: 0;
      text-align: center;
      font-size: 0.9rem;
      color: #bfbfbf;
      transition: opacity .5s ease;
      pointer-events: none;
    }
    #controls {
      position: absolute;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
      display: flex;
      gap: 10px;
    }
    #controls button{
      background:#222; color:#ddd; border:1px solid #333;
      padding:8px 14px; border-radius:8px; font-size:.95rem;
    }
    /* Hide buttons in landscape for kiosk look */
    @media (orientation: landscape) {
      #controls { display: none; }
      #hamburger-menu { display: none; }
    }
    
    /* Hamburger Menu Styles */
    .hamburger {
      position: fixed;
      top: env(safe-area-inset-top, 20px);
      right: 20px;
      width: 30px;
      height: 30px;
      cursor: pointer;
      z-index: 1000;
      padding: 5px;
    }
    
    .hamburger-lines span {
      display: block;
      height: 3px;
      width: 100%;
      background: #ddd;
      margin: 5px 0;
      transition: 0.3s;
      border-radius: 2px;
    }
    
    .hamburger.active .hamburger-lines span:nth-child(1) {
      transform: rotate(45deg) translate(8px, 8px);
    }
    
    .hamburger.active .hamburger-lines span:nth-child(2) {
      opacity: 0;
    }
    
    .hamburger.active .hamburger-lines span:nth-child(3) {
      transform: rotate(-45deg) translate(8px, -8px);
    }
    
    /* Settings Panel Styles */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 998;
    }
    
    .settings-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: min(400px, 90vw);
      height: 100vh;
      background: #1a1a1a;
      color: #ddd;
      z-index: 999;
      transform: translateX(100%);
      transition: transform 0.3s ease;
      overflow-y: auto;
      border-left: 1px solid #333;
    }
    
    .settings-panel.visible {
      transform: translateX(0);
    }
    
    .hidden {
      display: none;
    }
    
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      border-bottom: 1px solid #333;
    }
    
    .panel-header h3 {
      margin: 0;
      font-size: 1.2rem;
    }
    
    .close-btn {
      background: none;
      border: none;
      color: #ddd;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
    }
    
    .panel-content {
      padding: 20px;
    }
    
    .section {
      margin-bottom: 30px;
    }
    
    .section h4 {
      margin: 0 0 15px 0;
      font-size: 1rem;
      color: #fff;
    }
    
    .input-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .input-group input, .input-group select {
      background: #333;
      border: 1px solid #555;
      color: #ddd;
      padding: 8px;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    
    .input-group input[type="time"] {
      width: 120px;
    }
    
    .input-group input[type="number"] {
      width: 80px;
    }
    
    .input-group select {
      width: 180px;
    }
    
    .btn-primary, .btn-secondary {
      background: #333;
      border: 1px solid #555;
      color: #ddd;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background-color 0.2s;
    }
    
    .btn-primary:hover, .btn-secondary:hover {
      background: #444;
    }
    
    .btn-primary {
      background: #10b981;
      border-color: #10b981;
    }
    
    .btn-primary:hover {
      background: #0d9668;
    }
    
    #schedule-list {
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 15px;
      margin-bottom: 15px;
      min-height: 100px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .schedule-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid #444;
    }
    
    .schedule-item:last-child {
      border-bottom: none;
    }
    
    .schedule-time {
      font-weight: bold;
      color: #10b981;
    }
    
    .schedule-mode {
      font-size: 0.8rem;
      color: #999;
    }
    
    .delete-segment {
      background: #dc2626;
      border: none;
      color: white;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .url-display textarea {
      width: 100%;
      height: 80px;
      background: #2a2a2a;
      border: 1px solid #444;
      color: #ddd;
      padding: 10px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.8rem;
      resize: vertical;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <canvas id="clock"></canvas>
  <div id="controls">
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
  </div>
  <div id="message">Loading settings…</div>
  
  <!-- Hamburger Menu -->
  <div id="hamburger-menu" class="hamburger">
    <div class="hamburger-lines">
      <span></span>
      <span></span>
      <span></span>
    </div>
  </div>
  
  <!-- Settings Panel -->
  <div id="settings-panel" class="settings-panel hidden">
    <div class="panel-header">
      <h3>Timer Settings</h3>
      <button id="close-panel" class="close-btn">×</button>
    </div>
    
    <div class="panel-content">
      <div class="section">
        <h4>Current Schedule</h4>
        <div id="schedule-list">No segments configured</div>
        <button id="clear-schedule" class="btn-secondary">Clear All</button>
      </div>
      
      <div class="section">
        <h4>Add Segment</h4>
        <div class="input-group">
          <input type="time" id="segment-time" placeholder="HH:MM">
          <input type="number" id="segment-duration" placeholder="Minutes" min="1" max="480">
          <select id="segment-mode">
            <option value="down">Count Down (End Time)</option>
            <option value="up">Count Up (Start Time)</option>
          </select>
          <button id="add-segment" class="btn-primary">Add</button>
        </div>
      </div>
      
      <div class="section">
        <h4>URL Configuration</h4>
        <div class="url-display">
          <textarea id="current-url" readonly placeholder="Configure segments above to generate URL"></textarea>
          <button id="copy-url" class="btn-secondary">Copy URL</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Overlay -->
  <div id="settings-overlay" class="overlay hidden"></div>

  <script>
    const canvas = document.getElementById('clock');
    const ctx = canvas.getContext('2d', { alpha:false }); // opaque for perf
    const msg = document.getElementById('message');
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');

    let settings = null;
    let running = false;
    let manualRun = false;
    let segmentStartMs = null;        // ms timestamp when current segment started
    let segmentDurationSec = 2400;    // default 40m, overwritten by settings
    let autostartDone = false;
    let urlStartTime = null;          // URL parameter start time (HH:MM)
    let urlDuration = null;           // URL parameter duration in seconds
    let startAnim = null;             // animation start timestamp
    let countDown = true;             // true = count down (remaining), false = count up (elapsed)
    let timerSegments = [];           // array to store multiple timer segments
    let currentSegmentIndex = 0;      // index of currently active segment

    // --- Helpers -------------------------------------------------------------

    function showMessage(text, hideAfterMs = 2200) {
      msg.textContent = text;
      msg.style.opacity = 1;
      if (hideAfterMs) setTimeout(() => { msg.style.opacity = 0; }, hideAfterMs);
    }

    function resizeCanvas() {
      // full-screen canvas, drawing keeps a safe 90% inset ring so it never crops
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Angle of the **minute hand** for a given Date (radians, 0 at 12 o'clock)
    function minuteAngleAt(date) {
      const m = date.getMinutes();
      const s = date.getSeconds() + date.getMilliseconds()/1000;
      // 6 deg per minute, 0 at 12 o'clock => subtract 90 deg
      return ((m + s/60) * (Math.PI/30)) - Math.PI/2;
    }

    // --- URL Parameters --------------------------------------------------------
    
    function parseUrlParameters() {
      const urlParams = new URLSearchParams(window.location.search);
      const sParam = urlParams.get('s');
      const modeParam = urlParams.get('mode'); // 'up' or 'down'
      
      // Set count mode from URL parameter or default to countdown
      if (modeParam === 'up') {
        countDown = false;
      } else if (modeParam === 'down') {
        countDown = true;
      } else {
        countDown = true; // default to countdown
      }
      
      if (sParam) {
        const parts = sParam.split(',');
        
        // First part: 'a' means auto-start
        const autoStart = parts[0] === 'a';
        
        // Second part: HH:MM time format
        const timeRegex = /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/;
        if (parts.length > 1 && timeRegex.test(parts[1])) {
          const providedTime = parts[1];
          
          // Third part: duration in MINUTES (convert to seconds)
          if (parts.length > 2 && !isNaN(parts[2])) {
            const durationMinutes = parseInt(parts[2], 10);
            urlDuration = durationMinutes * 60; // convert to seconds
            
            if (countDown) {
              // COUNT DOWN: provided time is END time, calculate START time
              const [endH, endM] = providedTime.split(':').map(Number);
              const endTimeMs = new Date().setHours(endH, endM, 0, 0);
              const startTimeMs = endTimeMs - (urlDuration * 1000);
              const startTime = new Date(startTimeMs);
              const startH = startTime.getHours();
              const startM = startTime.getMinutes();
              urlStartTime = `${String(startH).padStart(2,'0')}:${String(startM).padStart(2,'0')}`;
            } else {
              // COUNT UP: provided time is START time
              urlStartTime = providedTime;
            }
          }
        }
        
        // Show what we parsed
        if (autoStart && urlStartTime && urlDuration) {
          const durationMsg = `, ${Math.round(urlDuration/60)}-minute segments`;
          let timeMsg, modeMsg;
          if (countDown) {
            modeMsg = ' (countdown)';
            timeMsg = `start ${urlStartTime}, end ${parts[1]}`;
          } else {
            modeMsg = ' (count up)';
            timeMsg = `start ${urlStartTime}`;
          }
          showMessage(`URL config: ${timeMsg}${durationMsg}${modeMsg}`, 4000);
          return true;
        }
      }
      return false;
    }
    
    // --- Settings ------------------------------------------------------------

    async function loadSettings() {
      // First check URL parameters
      if (parseUrlParameters()) {
        // Create settings object from URL params
        settings = {
          autoStart: urlStartTime,
          segmentDuration: urlDuration || 2400
        };
        segmentDurationSec = settings.segmentDuration;
        return;
      }
      
      // Fall back to settings.json if no URL parameters
      try {
        const res = await fetch('settings.json', { cache:'no-cache' });
        settings = await res.json();
        if (Number.isFinite(settings.segmentDuration)) {
          segmentDurationSec = settings.segmentDuration;
        }
        const autoTxt = settings.autoStart ? `autoStart ${settings.autoStart}` : 'manual start';
        showMessage(`Settings loaded: ${autoTxt}, ${Math.round(segmentDurationSec/60)}-minute segments`, 3000);
      } catch (e) {
        showMessage('Failed to load settings.json');
        console.error(e);
      }
    }

    // --- Start/Stop logic ----------------------------------------------------

    function startSegmentNow(isManual) {
      manualRun = !!isManual;
      segmentStartMs = Date.now();
      running = true;
      const when = new Date(segmentStartMs);
      const hh = String(when.getHours()).padStart(2,'0');
      const mm = String(when.getMinutes()).padStart(2,'0');
      showMessage(isManual ? `Manual start ${hh}:${mm}` : `Started ${hh}:${mm}`, 1800);
    }

    function stopSegment() {
      running = false;
      manualRun = false;
      segmentStartMs = null;
      showMessage('Stopped', 1500);
    }

    startBtn.addEventListener('click', () => {
      if (!settings) return;
      if (!running) startSegmentNow(true); // manual single run
    });

    stopBtn.addEventListener('click', stopSegment);

    // Check for auto-start at the exact minute HH:MM each second
    setInterval(() => {
      if (!settings || !settings.autoStart || running || autostartDone) return;
      const [H,M] = settings.autoStart.split(':').map(Number);
      const now = new Date();
      
      // Handle time-window case: if current time is past the start time and within duration
      if (urlStartTime && urlDuration) {
        const startMs = new Date().setHours(H, M, 0, 0);
        const currentMs = now.getTime();
        const endMs = startMs + (urlDuration * 1000);
        
        // If we're already inside the time window, start immediately
        if (currentMs >= startMs && currentMs < endMs) {
          // Calculate how much time has already elapsed in the segment
          const elapsedMs = currentMs - startMs;
          // Set segment start time to when it would have actually started
          segmentStartMs = currentMs - elapsedMs;
          autostartDone = true;
          running = true;
          showMessage(`Started mid-session (${Math.floor(elapsedMs/1000)}s elapsed)`, 2500);
          return;
        }
      }
      
      // Standard check for exact start time match
      if (now.getHours() === H && now.getMinutes() === M) {
        autostartDone = true;
        startSegmentNow(false); // scheduled/rolling
      }
    }, 1000);

    // --- Drawing Functions --------------------------------------------------
    
    function drawTimerArc(ctx, cx, cy, r, animProgress) {
      if (!running || segmentStartMs == null) return;
      
      const nowMs = Date.now();
      const elapsedSec = Math.max(0, (nowMs - segmentStartMs) / 1000);
      const clamped = Math.min(elapsedSec, segmentDurationSec);
      const progress = clamped / segmentDurationSec;

      // ARC GEOMETRY:
      // Start angle is the minute hand angle at the moment the segment started
      const startAngle = minuteAngleAt(new Date(segmentStartMs));
      // Span for this segment: 6° per minute => durationSec * (π/1800) radians
      const span = segmentDurationSec * (Math.PI / 1800);
      const endAngle = startAngle + span;
      
      // Calculate arc endpoints based on count mode
      let coloredStartAngle, coloredEndAngle;
      if (countDown) {
        // COUNT DOWN: Remaining arc starts where elapsed time ends and goes to the original end
        coloredStartAngle = startAngle + clamped * (Math.PI / 1800);
        coloredEndAngle = endAngle;
      } else {
        // COUNT UP: Elapsed arc starts at original start and goes to current progress
        coloredStartAngle = startAngle;
        coloredEndAngle = startAngle + clamped * (Math.PI / 1800);
      }

      // Apply animation scaling to the arcs
      const animatedRadius = r * 0.88 * animProgress;
      const animatedLineWidth = 22 * animProgress;

      // Segment track (grey) - shows full duration
      ctx.beginPath();
      ctx.arc(cx, cy, animatedRadius, startAngle, endAngle, false);
      ctx.strokeStyle = '#555';
      ctx.lineWidth = animatedLineWidth;
      ctx.lineCap = 'round';
      ctx.stroke();

      // Progress color based on remaining time (green → orange last 10m → red last 5m)
      const remaining = segmentDurationSec - clamped;
      let progColor = '#22c55e';
      if (remaining <= 300) progColor = '#ef4444';
      else if (remaining <= 600) progColor = '#f59e0b';

      // Progress arc (colored) - shows either elapsed time (count up) or remaining time (count down)
      ctx.beginPath();
      ctx.arc(cx, cy, animatedRadius, coloredStartAngle, coloredEndAngle, false);
      ctx.strokeStyle = progColor;
      ctx.lineWidth = animatedLineWidth;
      ctx.lineCap = 'round';
      ctx.stroke();

      // When a segment completes:
      if (clamped >= segmentDurationSec) {
        if (manualRun) {
          // Manual: stop after one
          stopSegment();
        } else {
          // Scheduled/rolling: immediately start next segment anchored to the minute hand now
          startSegmentNow(false);
        }
      }
    }
    
    function drawHands(ctx, cx, cy, r, now, animProgress) {
      const s = now.getSeconds() + now.getMilliseconds()/1000;
      const m = now.getMinutes() + s/60;
      const h12 = (now.getHours()%12) + m/60;

      // Hour hand
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(h12 * (Math.PI/6) - Math.PI/2) * (r*0.50 * animProgress),
                 cy + Math.sin(h12 * (Math.PI/6) - Math.PI/2) * (r*0.50 * animProgress));
      ctx.strokeStyle = '#e6e6e6';
      ctx.lineWidth = 20 * animProgress;
      ctx.lineCap = 'round';
      ctx.stroke();

      // Minute hand
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(m * (Math.PI/30) - Math.PI/2) * (r*0.75 * animProgress),
                 cy + Math.sin(m * (Math.PI/30) - Math.PI/2) * (r*0.75 * animProgress));
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 10 * animProgress;
      ctx.lineCap = 'round';
      ctx.stroke();

      // Second hand
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(s * (Math.PI/30) - Math.PI/2) * (r*0.86 * animProgress),
                 cy + Math.sin(s * (Math.PI/30) - Math.PI/2) * (r*0.86 * animProgress));
      ctx.strokeStyle = '#FDDA0D'; // cadmium yellow
      ctx.lineWidth = 3 * animProgress;
      ctx.lineCap = 'round';
      ctx.stroke();

      // Center pivot (yellow – terminal of second hand at the hub)
      ctx.beginPath();
      ctx.arc(cx, cy, 16 * animProgress, 0, Math.PI*2);
      ctx.fillStyle = '#FDDA0D';
      ctx.fill();
    }

    // --- Main animation loop ------------------------------------------------
    
    function draw() {
      requestAnimationFrame(draw);
      
      const w = canvas.width, h = canvas.height;
      
      // Layout: keep a 90% square inside viewport; draw ring at r
      const size = Math.min(w,h) * 0.9;
      const r = size/2;
      const cx = w/2, cy = h/2;
      
      // Sweep-in easing calculation
      let animProgress = 1;
      if (startAnim !== null) {
        let t = Math.min(1, (performance.now() - startAnim) / 1500);
        animProgress = t < 1 ? (1 - Math.cos(t * Math.PI)) / 2 : 1; // easeInOut
      }
      
      ctx.clearRect(0, 0, w, h);
      ctx.save();
      ctx.globalAlpha = animProgress; // fade-in

      // === Reference outline circle (subtle guide) ===
      ctx.beginPath();
      ctx.arc(cx, cy, r * animProgress, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 2 * animProgress;
      ctx.stroke();

      // === Draw timer arc and clock hands ===
      const now = new Date();
      drawTimerArc(ctx, cx, cy, r, animProgress);
      drawHands(ctx, cx, cy, r, now, animProgress);
      
      ctx.restore();
    }

    // --- Settings Panel Management -------------------------------------------
    
    const hamburgerMenu = document.getElementById('hamburger-menu');
    const settingsPanel = document.getElementById('settings-panel');
    const settingsOverlay = document.getElementById('settings-overlay');
    const closePanel = document.getElementById('close-panel');
    const scheduleList = document.getElementById('schedule-list');
    const clearScheduleBtn = document.getElementById('clear-schedule');
    const addSegmentBtn = document.getElementById('add-segment');
    const copyUrlBtn = document.getElementById('copy-url');
    const currentUrlTextarea = document.getElementById('current-url');
    
    function openSettingsPanel() {
      settingsPanel.classList.remove('hidden');
      settingsOverlay.classList.remove('hidden');
      hamburgerMenu.classList.add('active');
      setTimeout(() => {
        settingsPanel.classList.add('visible');
      }, 10);
      updateScheduleDisplay();
      generateUrl();
    }
    
    function closeSettingsPanel() {
      settingsPanel.classList.remove('visible');
      hamburgerMenu.classList.remove('active');
      setTimeout(() => {
        settingsPanel.classList.add('hidden');
        settingsOverlay.classList.add('hidden');
      }, 300);
    }
    
    function updateScheduleDisplay() {
      if (timerSegments.length === 0) {
        scheduleList.innerHTML = 'No segments configured';
        return;
      }
      
      scheduleList.innerHTML = timerSegments.map((segment, index) => `
        <div class="schedule-item">
          <div>
            <div class="schedule-time">${segment.time}</div>
            <div class="schedule-mode">${segment.duration}min (${segment.mode === 'up' ? 'Count Up - Start Time' : 'Count Down - End Time'})</div>
          </div>
          <button class="delete-segment" onclick="deleteSegment(${index})">×</button>
        </div>
      `).join('');
    }
    
    function deleteSegment(index) {
      timerSegments.splice(index, 1);
      updateScheduleDisplay();
      generateUrl();
    }
    
    function clearAllSegments() {
      timerSegments = [];
      updateScheduleDisplay();
      generateUrl();
      showMessage('All segments cleared', 1500);
    }
    
    function addSegment() {
      const timeInput = document.getElementById('segment-time');
      const durationInput = document.getElementById('segment-duration');
      const modeSelect = document.getElementById('segment-mode');
      
      if (!timeInput.value || !durationInput.value) {
        showMessage('Please fill in time and duration', 2000);
        return;
      }
      
      const newSegment = {
        time: timeInput.value,
        duration: parseInt(durationInput.value),
        mode: modeSelect.value
      };
      
      timerSegments.push(newSegment);
      timerSegments.sort((a, b) => {
        // Sort by time
        const timeA = a.time.split(':').map(Number);
        const timeB = b.time.split(':').map(Number);
        return (timeA[0] * 60 + timeA[1]) - (timeB[0] * 60 + timeB[1]);
      });
      
      // Clear inputs
      timeInput.value = '';
      durationInput.value = '';
      
      updateScheduleDisplay();
      generateUrl();
      showMessage(`Segment added: ${newSegment.time} (${newSegment.duration}min)`, 2000);
    }
    
    function generateUrl() {
      if (timerSegments.length === 0) {
        currentUrlTextarea.value = 'Add segments above to generate URL';
        return;
      }
      
      const baseUrl = window.location.origin + window.location.pathname;
      
      if (timerSegments.length === 1) {
        // Single segment - use original format
        const segment = timerSegments[0];
        const url = `${baseUrl}?s=a,${segment.time},${segment.duration}&mode=${segment.mode}`;
        currentUrlTextarea.value = url;
      } else {
        // Multiple segments - use new format
        const segmentParams = timerSegments.map(s => `${s.time},${s.duration},${s.mode}`).join('|');
        const url = `${baseUrl}?segments=${encodeURIComponent(segmentParams)}`;
        currentUrlTextarea.value = url;
      }
    }
    
    async function copyUrl() {
      try {
        await navigator.clipboard.writeText(currentUrlTextarea.value);
        showMessage('URL copied to clipboard!', 2000);
      } catch (err) {
        // Fallback for older browsers
        currentUrlTextarea.select();
        document.execCommand('copy');
        showMessage('URL copied!', 2000);
      }
    }
    
    // Event listeners
    hamburgerMenu.addEventListener('click', openSettingsPanel);
    closePanel.addEventListener('click', closeSettingsPanel);
    settingsOverlay.addEventListener('click', closeSettingsPanel);
    clearScheduleBtn.addEventListener('click', clearAllSegments);
    addSegmentBtn.addEventListener('click', addSegment);
    copyUrlBtn.addEventListener('click', copyUrl);
    
    // Make deleteSegment available globally
    window.deleteSegment = deleteSegment;
    
    // Load segments from URL on init
    function loadSegmentsFromUrl() {
      const urlParams = new URLSearchParams(window.location.search);
      const segmentsParam = urlParams.get('segments');
      
      if (segmentsParam) {
        try {
          const segmentStrings = decodeURIComponent(segmentsParam).split('|');
          timerSegments = segmentStrings.map(segStr => {
            const [time, duration, mode] = segStr.split(',');
            return {
              time: time,
              duration: parseInt(duration),
              mode: mode || 'down'
            };
          });
          showMessage(`Loaded ${timerSegments.length} segments from URL`, 3000);
        } catch (e) {
          console.error('Error parsing segments from URL:', e);
          showMessage('Error loading segments from URL', 2000);
        }
      }
    }

    // --- Init ----------------------------------------------------------------
    loadSegmentsFromUrl();
    loadSettings().then(() => {
      startAnim = performance.now(); // Start the sweep-in animation
      requestAnimationFrame(draw);
    });
  </script>
</body>
</html>