<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>40-Minute Cycling Timer</title>
<style>
    html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        background: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #ccc;
        font-family: Arial, sans-serif;
    }
    #canvasContainer {
        position: relative;
        width: 100vmin;
        height: 100vmin;
    }
    canvas {
        display: block;
        background: #000;
    }
    #status {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        font-size: 14px;
        color: #aaa;
    }
    .controls {
        position: absolute;
        bottom: 20px;
        width: 100%;
        text-align: center;
    }
    button {
        font-size: 16px;
        padding: 10px 20px;
        border-radius: 8px;
        border: none;
        background: rgba(255,255,255,0.2);
        color: #fff;
        margin: 0 5px;
        cursor: pointer;
    }
</style>
</head>
<body>
<div id="canvasContainer">
    <div id="status">Loading settings...</div>
    <canvas id="clockCanvas"></canvas>
    <div class="controls">
        <button id="startBtn">Start</button>
        <button id="stopBtn">Stop</button>
    </div>
</div>

<script>
const canvas = document.getElementById('clockCanvas');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');

let settings = null;
let segmentIndex = 0;
let elapsed = 0;
let totalDuration = 0;
let timerInterval = null;

// Ensure square canvas
function resizeCanvas() {
    const size = Math.min(window.innerWidth, window.innerHeight);
    canvas.width = size;
    canvas.height = size;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Load settings from GitHub
fetch('https://raw.githubusercontent.com/piarasj/timer/517a5566a35abb8bf642716b24f5314dcbfcb068/settings.json')
.then(resp => resp.json())
.then(data => {
    settings = data;
    totalDuration = settings.segments[0].duration;
    statusEl.textContent = `Settings loaded: Auto-start at ${settings.autoStart}, ${totalDuration/60} min segments`;
    checkAutoStart();
})
.catch(err => statusEl.textContent = 'Error loading settings: ' + err);

// Draw clock elements
function drawClock() {
    const w = canvas.width;
    const h = canvas.height;
    const cx = w/2;
    const cy = h/2;
    const r = w*0.45;
    
    ctx.clearRect(0,0,w,h);
    
    // Grey track (segment path)
    if(settings){
        const seg = settings.segments[segmentIndex];
        const startRad = (seg.startAngle) * Math.PI/180;
        const endRad = startRad + (seg.duration/totalDuration)*2*Math.PI;
        ctx.beginPath();
        ctx.lineWidth = 14;
        ctx.strokeStyle = '#444';
        ctx.lineCap = 'round';
        ctx.arc(cx, cy, r, startRad, endRad);
        ctx.stroke();
        
        // Progress arc
        const progressRad = startRad + (elapsed/seg.duration)*(endRad-startRad);
        let color = '#22c55e';
        if(elapsed/seg.duration > 0.75) color = '#ef4444';
        else if(elapsed/seg.duration > 0.5) color = '#f59e0b';
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.arc(cx, cy, r, startRad, progressRad);
        ctx.stroke();
    }
    
    // Clock hands
    const now = new Date();
    const sec = now.getSeconds() + now.getMilliseconds()/1000;
    const min = now.getMinutes() + sec/60;
    const hr = now.getHours()%12 + min/60;
    
    // Hour hand
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(hr*Math.PI/6);
    ctx.lineWidth = 8;
    ctx.strokeStyle = '#fff';
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(0,-r*0.5);
    ctx.stroke();
    ctx.restore();
    
    // Minute hand
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(min*Math.PI/30);
    ctx.lineWidth = 6;
    ctx.strokeStyle = '#fff';
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(0,-r*0.75);
    ctx.stroke();
    ctx.restore();
    
    // Second hand
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(sec*Math.PI/30);
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#FDDA0D';
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(0,-r*0.85);
    ctx.stroke();
    
    // Dot at origin
    ctx.fillStyle = '#FDDA0D';
    ctx.beginPath();
    ctx.arc(0,0,6,0,2*Math.PI);
    ctx.fill();
    ctx.restore();
    
    requestAnimationFrame(drawClock);
}

drawClock();

// Timer functions
function startTimer() {
    if(!settings) return;
    const seg = settings.segments[segmentIndex];
    if(timerInterval) clearInterval(timerInterval);
    elapsed = 0;
    statusEl.style.display = 'none';
    timerInterval = setInterval(()=>{
        elapsed++;
        if(elapsed>=seg.duration){
            elapsed = 0;
            segmentIndex = (segmentIndex+1)%settings.segments.length;
        }
    },1000);
}

function stopTimer() {
    if(timerInterval) clearInterval(timerInterval);
}

startBtn.addEventListener('click', startTimer);
stopBtn.addEventListener('click', stopTimer);

// Auto-start
function checkAutoStart(){
    if(!settings) return;
    const now = new Date();
    const [h,m] = settings.autoStart.split(':').map(Number);
    if(now.getHours()===h && now.getMinutes()===m){
        startTimer();
    }
}
setInterval(checkAutoStart,1000);
</script>
</body>
</html>