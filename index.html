<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>40-Minute Cycling Timer</title>
  <style>
    body {
      margin: 0;
      background: black;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      color: #aaa;
      font-family: sans-serif;
    }
    #message {
      position: absolute;
      top: 10px;
      font-size: 0.9em;
      color: #888;
      transition: opacity 1s ease;
    }
    #controls {
      position: absolute;
      bottom: 10px;
    }
    @media (orientation: landscape) {
      #controls { display: none; }
    }
  </style>
</head>
<body>
  <div id="message">Loading settingsâ€¦</div>
  <canvas id="clock"></canvas>
  <div id="controls">
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
  </div>
  <script>
    const canvas = document.getElementById("clock");
    const ctx = canvas.getContext("2d");
    const message = document.getElementById("message");
    let settings = null;
    let segments = [];
    let currentSegment = null;
    let manualRun = false;

    // Resize canvas properly in both orientations
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // Load settings.json
    async function loadSettings() {
      try {
        const response = await fetch("settings.json");
        settings = await response.json();
        segments = settings.segments;
        showMessage(`Settings loaded: duration ${settings.segmentDuration / 60} min`);
      } catch (e) {
        showMessage("Failed to load settings.json");
      }
    }

    function showMessage(text) {
      message.textContent = text;
      message.style.opacity = 1;
    }
    function hideMessage() {
      message.style.opacity = 0;
    }

    // Convert time string (HH:MM) to Date today
    function parseTime(str) {
      const [h, m] = str.split(":").map(Number);
      const d = new Date();
      d.setHours(h, m, 0, 0);
      return d;
    }

    function startSegment(seg, isManual = false) {
      currentSegment = {
        start: seg.start,
        end: new Date(seg.start.getTime() + seg.duration * 1000),
        duration: seg.duration
      };
      manualRun = isManual;
      showMessage(`Segment started: ${seg.duration/60} min`);
      setTimeout(hideMessage, 2000);
    }

    // Manual start button
    document.getElementById("startBtn").addEventListener("click", () => {
      const now = new Date();
      startSegment({ start: now, duration: settings.segmentDuration }, true);
    });

    document.getElementById("stopBtn").addEventListener("click", () => {
      currentSegment = null;
      manualRun = false;
      showMessage("Stopped");
      setTimeout(hideMessage, 2000);
    });

    function drawClock() {
      const w = canvas.width;
      const h = canvas.height;
      const size = Math.min(w, h) * 0.9;
      const r = size / 2;
      const cx = w / 2;
      const cy = h / 2;

      ctx.clearRect(0, 0, w, h);

      // Base outline circle (helps show oval distortion)
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, 2 * Math.PI);
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw current segment track if active
      if (currentSegment) {
        const now = new Date();
        const elapsed = (now - currentSegment.start) / 1000;
        const progress = Math.max(0, Math.min(1, elapsed / currentSegment.duration));

        // Arc positions
        const startAngle = -Math.PI / 2;
        const endAngle = startAngle + 2 * Math.PI * (currentSegment.duration / 3600); 
        // Full circle would be 3600s = 1hr. Here mapping duration to circle.

        // Grey track
        ctx.beginPath();
        ctx.arc(cx, cy, r * 0.9, startAngle, endAngle);
        ctx.strokeStyle = "#555";
        ctx.lineWidth = 16;
        ctx.lineCap = "round";
        ctx.stroke();

        // Progress color
        let color = "green";
        const remain = currentSegment.duration - elapsed;
        if (remain <= 300) color = "red";
        else if (remain <= 600) color = "orange";

        ctx.beginPath();
        ctx.arc(cx, cy, r * 0.9, startAngle, startAngle + (endAngle - startAngle) * progress);
        ctx.strokeStyle = color;
        ctx.lineWidth = 16;
        ctx.lineCap = "round";
        ctx.stroke();

        // Auto-advance only if not manual
        if (!manualRun && elapsed >= currentSegment.duration) {
          const idx = segments.findIndex(s => s.start.getTime() === currentSegment.start.getTime());
          if (idx >= 0 && idx + 1 < segments.length) {
            startSegment(segments[idx + 1]);
          } else {
            currentSegment = null;
          }
        }

        // Manual run stops after one segment
        if (manualRun && elapsed >= currentSegment.duration) {
          currentSegment = null;
          manualRun = false;
        }
      }

      // Draw clock hands
      const now = new Date();
      const sec = now.getSeconds();
      const min = now.getMinutes();
      const hr = now.getHours();

      // Hour hand
      ctx.beginPath();
      ctx.lineWidth = 6;
      ctx.moveTo(cx, cy);
      ctx.lineTo(
        cx + r * 0.5 * Math.cos((Math.PI/6) * (hr % 12 + min / 60) - Math.PI/2),
        cy + r * 0.5 * Math.sin((Math.PI/6) * (hr % 12 + min / 60) - Math.PI/2)
      );
      ctx.strokeStyle = "white";
      ctx.stroke();

      // Minute hand
      ctx.beginPath();
      ctx.lineWidth = 4;
      ctx.moveTo(cx, cy);
      ctx.lineTo(
        cx + r * 0.7 * Math.cos((Math.PI/30) * (min + sec / 60) - Math.PI/2),
        cy + r * 0.7 * Math.sin((Math.PI/30) * (min + sec / 60) - Math.PI/2)
      );
      ctx.strokeStyle = "white";
      ctx.stroke();

      // Second hand
      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.moveTo(cx, cy);
      ctx.lineTo(
        cx + r * 0.8 * Math.cos((Math.PI/30) * sec - Math.PI/2),
        cy + r * 0.8 * Math.sin((Math.PI/30) * sec - Math.PI/2)
      );
      ctx.strokeStyle = "#FDDA0D"; // Cadmium yellow
      ctx.stroke();

      // Yellow terminal dot
      ctx.beginPath();
      ctx.arc(
        cx + r * 0.8 * Math.cos((Math.PI/30) * sec - Math.PI/2),
        cy + r * 0.8 * Math.sin((Math.PI/30) * sec - Math.PI/2),
        5, 0, 2 * Math.PI
      );
      ctx.fillStyle = "#FDDA0D";
      ctx.fill();

      requestAnimationFrame(drawClock);
    }

    loadSettings().then(() => {
      requestAnimationFrame(drawClock);
    });
  </script>
</body>
</html>