<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>40-Minute Cycling Timer</title>
  <style>
    body {
      margin: 0;
      background: black;
      color: lightgray;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    #controls {
      position: absolute;
      bottom: 10px;
      display: flex;
      gap: 10px;
    }
    #controls button {
      padding: 6px 12px;
      border-radius: 6px;
      border: none;
      background: #333;
      color: lightgray;
      font-size: 14px;
    }
    #message {
      position: absolute;
      top: 10px;
      font-size: 12px;
      color: lightgray;
      opacity: 0.7;
    }
    @media (orientation: landscape) {
      #controls { display: none; }
    }
  </style>
</head>
<body>
  <canvas id="clock"></canvas>
  <div id="controls">
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
  </div>
  <div id="message"></div>

  <script>
    const canvas = document.getElementById("clock");
    const ctx = canvas.getContext("2d");
    const messageEl = document.getElementById("message");
    let settings = null;
    let running = false;
    let segmentStart = null;
    let segmentEnd = null;
    let currentSegmentIndex = null;
    let manual = false;

    // Resize canvas to always be square
    function resizeCanvas() {
      const size = Math.min(window.innerWidth, window.innerHeight);
      canvas.width = size;
      canvas.height = size;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // Load settings.json
    fetch("settings.json")
      .then(res => res.json())
      .then(data => {
        settings = data;
        showMessage(`Settings loaded: autoStart ${settings.autoStart || "none"}, duration ${settings.segmentDuration/60} min`);
        if (settings.autoStart) tryAutoStart();
      })
      .catch(err => showMessage("Failed to load settings: " + err));

    function showMessage(text, timeout=3000) {
      messageEl.textContent = text;
      if (timeout) {
        setTimeout(() => { messageEl.textContent = ""; }, timeout);
      }
    }

    // Try to autostart from settings.autoStart
    function tryAutoStart() {
      if (!settings || !settings.autoStart) return;
      const now = new Date();
      const [h, m] = settings.autoStart.split(":").map(Number);
      const start = new Date();
      start.setHours(h, m, 0, 0);
      if (now >= start) {
        segmentStart = start.getTime();
        segmentEnd = segmentStart + settings.segmentDuration * 1000;
        running = true;
        manual = false;
        showMessage("Auto-started from settings", 2000);
      }
    }

    // Button actions
    document.getElementById("startBtn").addEventListener("click", () => {
      if (!settings) return;
      if (!running) {
        const seg = findCurrentSegment();
        if (seg) {
          // Start scheduled segment
          segmentStart = seg.start.getTime();
          segmentEnd = segmentStart + seg.duration * 1000;
          running = true;
          manual = false;
          currentSegmentIndex = seg.index;
          showMessage("Started scheduled segment", 2000);
        } else {
          // Start manual segment
          segmentStart = Date.now();
          segmentEnd = segmentStart + settings.segmentDuration * 1000;
          running = true;
          manual = true;
          currentSegmentIndex = -1;
          showMessage("Manual timer started", 2000);
        }
      }
    });

    document.getElementById("stopBtn").addEventListener("click", () => {
      running = false;
      showMessage("Stopped", 2000);
    });

    // Find if we're inside a scheduled segment
    function findCurrentSegment() {
      if (!settings || !settings.segments) return null;
      const now = new Date();
      const timeMs = now.getTime();
      for (let i = 0; i < settings.segments.length; i++) {
        const seg = settings.segments[i];
        const [h, m] = seg.startTime.split(":").map(Number);
        const start = new Date();
        start.setHours(h, m, 0, 0);
        const end = start.getTime() + seg.duration * 1000;
        if (timeMs >= start.getTime() && timeMs < end) {
          return { index: i, start, duration: seg.duration, startAngle: seg.startAngle };
        }
      }
      return null;
    }

    // Main drawing
    function draw() {
      const w = canvas.width;
      const h = canvas.height;
      const r = (Math.min(w, h) * 0.9) / 2;
      const cx = w/2, cy = h/2;
      ctx.clearRect(0, 0, w, h);

      // Base grey circle outline
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, 2*Math.PI);
      ctx.strokeStyle = "#444";
      ctx.lineWidth = 2;
      ctx.stroke();

      if (running && segmentStart && segmentEnd) {
        const now = Date.now();
        const total = segmentEnd - segmentStart;
        const elapsed = Math.max(0, Math.min(now - segmentStart, total));
        const progress = elapsed / total;

        // Get angles for track
        let startAngle, endAngle;
        if (!manual && currentSegmentIndex != null && currentSegmentIndex >= 0) {
          startAngle = (settings.segments[currentSegmentIndex].startAngle) * Math.PI/180;
          endAngle = startAngle + 2*Math.PI * (settings.segments[currentSegmentIndex].duration / settings.segmentDuration);
        } else {
          // Manual run: whole circle
          startAngle = -Math.PI/2;
          endAngle = startAngle + 2*Math.PI;
        }

        // Draw track (grey arc)
        ctx.beginPath();
        ctx.arc(cx, cy, r, startAngle, endAngle);
        ctx.strokeStyle = "#555";
        ctx.lineWidth = 16;
        ctx.lineCap = "round";
        ctx.stroke();

        // Draw progress arc
        const progAngle = startAngle + (endAngle - startAngle) * progress;
        ctx.beginPath();
        ctx.arc(cx, cy, r, startAngle, progAngle);
        if (elapsed >= total - 300000) {
          ctx.strokeStyle = "red"; // last 5 minutes
        } else if (elapsed >= total - 600000) {
          ctx.strokeStyle = "orange"; // last 10 minutes
        } else {
          ctx.strokeStyle = "lime"; // normal
        }
        ctx.lineWidth = 16;
        ctx.lineCap = "round";
        ctx.stroke();

        // Hands (hour, minute, second)
        const date = new Date();
        const sec = date.getSeconds() + date.getMilliseconds()/1000;
        const min = date.getMinutes() + sec/60;
        const hr = date.getHours()%12 + min/60;

        // Hour hand
        drawHand(cx, cy, (hr/12)*2*Math.PI - Math.PI/2, r*0.5, 6, "lightgray");
        // Minute hand
        drawHand(cx, cy, (min/60)*2*Math.PI - Math.PI/2, r*0.7, 4, "lightgray");
        // Second hand
        drawHand(cx, cy, (sec/60)*2*Math.PI - Math.PI/2, r*0.85, 2, "#FDDA0D");
      }

      requestAnimationFrame(draw);
    }

    function drawHand(cx, cy, angle, length, width, color) {
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(angle) * length, cy + Math.sin(angle) * length);
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.lineCap = "round";
      ctx.stroke();
    }

    draw();
  </script>
</body>
</html>