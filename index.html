<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>40-Minute Timer</title>
  <style>
    body {
      margin: 0;
      background: black;
      color: lightgray;
      font-family: sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    #message {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      font-size: 0.9rem;
      color: lightgray;
      opacity: 0.7;
    }
  </style>
</head>
<body>
  <div id="message">Loading settingsâ€¦</div>
  <canvas id="clock"></canvas>

  <script>
    const canvas = document.getElementById("clock");
    const ctx = canvas.getContext("2d");
    const messageEl = document.getElementById("message");

    let settings = null;
    let currentSegment = 0;
    let segmentStartTime = null;
    let timerRunning = false;

    // === Resize canvas square-locked ===
    function resizeCanvas() {
      const side = Math.min(window.innerWidth, window.innerHeight);
      canvas.width = side;
      canvas.height = side;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // === Load settings.json ===
    async function loadSettings() {
      try {
        const res = await fetch("settings.json");
        settings = await res.json();
        messageEl.textContent = `Settings loaded: ${settings.segmentDuration/60}-minute segments`;
        if (settings.autoStart) {
          const [h, m] = settings.autoStart.split(":").map(Number);
          const now = new Date();
          if (now.getHours() === h && now.getMinutes() === m) {
            startSegment(0);
          }
        }
      } catch (e) {
        messageEl.textContent = "Failed to load settings.json";
        console.error(e);
      }
    }

    // === Start a segment ===
    function startSegment(index) {
      currentSegment = index;
      segmentStartTime = Date.now();
      timerRunning = true;
      messageEl.style.display = "none";
    }

    // === Draw loop ===
    function draw() {
      const width = canvas.width;
      const height = canvas.height;
      const size = Math.min(width, height) * 0.9;
      const r = size / 2;
      const cx = width / 2;
      const cy = height / 2;
      ctx.clearRect(0, 0, width, height);

      // === Reference circle ===
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, 2 * Math.PI);
      ctx.strokeStyle = "#444";
      ctx.lineWidth = 2;
      ctx.stroke();

      if (settings && timerRunning) {
        const seg = settings.segments[currentSegment];
        const duration = seg.duration * 1000; // ms
        const elapsed = Date.now() - segmentStartTime;
        const progress = Math.min(elapsed / duration, 1);

        const startAngle = (seg.startAngle * Math.PI) / 180;
        const endAngle = startAngle + (2 * Math.PI * (seg.duration / settings.segmentDuration));

        // === Grey track arc ===
        ctx.beginPath();
        ctx.arc(cx, cy, r - 10, startAngle, endAngle);
        ctx.strokeStyle = "#555";
        ctx.lineWidth = 20;
        ctx.lineCap = "round";
        ctx.stroke();

        // === Progress arc with colour transitions ===
        let color = "green";
        const remaining = (1 - progress) * seg.duration;
        if (remaining <= 300) color = "red";     // last 5 minutes
        else if (remaining <= 600) color = "orange"; // last 10 minutes

        ctx.beginPath();
        ctx.arc(cx, cy, r - 10, startAngle, startAngle + (endAngle - startAngle) * progress);
        ctx.strokeStyle = color;
        ctx.lineWidth = 20;
        ctx.lineCap = "round";
        ctx.stroke();
      }

      // === Clock hands ===
      const now = new Date();
      const sec = now.getSeconds();
      const min = now.getMinutes();
      const hr = now.getHours();

      // Hour hand
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(
        cx + Math.cos(((hr % 12) + min / 60) * (Math.PI / 6) - Math.PI / 2) * (r * 0.5),
        cy + Math.sin(((hr % 12) + min / 60) * (Math.PI / 6) - Math.PI / 2) * (r * 0.5)
      );
      ctx.strokeStyle = "white";
      ctx.lineWidth = 6;
      ctx.stroke();

      // Minute hand
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(
        cx + Math.cos((min + sec / 60) * (Math.PI / 30) - Math.PI / 2) * (r * 0.75),
        cy + Math.sin((min + sec / 60) * (Math.PI / 30) - Math.PI / 2) * (r * 0.75)
      );
      ctx.strokeStyle = "white";
      ctx.lineWidth = 4;
      ctx.stroke();

      // Second hand
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(
        cx + Math.cos(sec * (Math.PI / 30) - Math.PI / 2) * (r * 0.85),
        cy + Math.sin(sec * (Math.PI / 30) - Math.PI / 2) * (r * 0.85)
      );
      ctx.strokeStyle = "#FDDA0D"; // yellow
      ctx.lineWidth = 2;
      ctx.stroke();

      // === Center pivot ===
      ctx.beginPath();
      ctx.arc(cx, cy, 6, 0, 2 * Math.PI);
      ctx.fillStyle = "#FDDA0D"; // yellow, matches second hand
      ctx.fill();

      requestAnimationFrame(draw);
    }

    loadSettings();
    draw();
  </script>
</body>
</html>